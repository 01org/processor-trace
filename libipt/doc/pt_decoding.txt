Decoding Intel(R) Processor Trace (PT) using libipt
====================================================

Copyright (C) 2013 Intel Corporation.  All rights reserved.


Introduction
------------

First of all, libipt is not sufficient for producing an execution trace
disassembly, a trace of linear instruction addresses, or even a trace of from/to
address pairs by itself. It is meant to decode the raw PT data and to guide a
user who wants to produce one of the above.

A user of libipt will need to provide an instruction decoder as well as the
main loop for decoding the trace. The user is expected to drive the decoding.

As long as control flow is obvious from the disassembly, the user will continue
on its own. At places where control flow is not obvious, he will ask libipt for
guidance. In addition to that, libipt will notify the user about asynchronous
events.


Configuration
-------------

The first step is to create and configure a PT decoder. The PT configuration
specifies PT parameters that are required for decoding.

Libipt provides a structure for specifying the PT configuration:

         struct pt_config;


The configuration structure contains the following fields:

  - size                This is to be set to the size of the structure.

                        It is used for providing backwards compatibility in
                        future versions of libipt.

  - begin, end          This defines the PT buffer.

                        The buffer is defined as [begin; end[.
                        The PT stream is expected to start at begin.

                        The configuration is used for encoding and for decoding,
                        so the buffer is non-const. The decoder will not write
                        into the PT buffer unless the optional unknown packet
                        decoder below does.

  - decode              An optional callback function for handling unknown
                        packets.

                        The callback will be called for any unknown opcode.

                        The callback also receives an optional pointer to a
                        struct pt_packet, which it is expected to fill in
                        appropriately.

                        It shall return the number of bytes read upon success.
                        It shall return a negative pt_error_code otherwise.

  - cpuid               The cpu family, model, and stepping as defined by
                        cpuid leaf 1.0.


The system-dependent part of the configuration structure can be filled
in by calling:

         int pt_configure(struct pt_config *);

on the system on which PT is collected.


Once the configuration is filled in, a PT decoder can be allocated:

         struct pt_decoder *pt_alloc_decoder(const struct pt_config *);


After finishing decoding, the allocated PT decoder should be freed:

         void pt_free_decoder(struct pt_decoder *);


Synchronization
---------------

PT is a stream of variable-length packets. Before we may start decoding, we
need to synchronize on that stream. At regular intervals, the PT stream
contains synchronization packets.

Libipt provides two functions for synchronization with the PT stream:

         int pt_sync_forward(struct pt_decoder *);
         int pt_sync_backward(struct pt_decoder *);

They will search for the next synchronization packet in forward or backward
direction, respectively. By repeatedly calling one of those functions, we may
iterate over the synchronization points in the stream. This may be used for
parallel decoding, for example.

Should synchronization fail for some reason, we repeat the request until we
synchronized successfully or ran out of PT data. This will skip some PT
segments.


Decoding
--------

At the lowest level, libipt supports decoding PT packets:

         int pt_decode(struct pt_packet *, struct pt_decoder *);

This function decodes the packet at the decoder's current position and returns
the number of bytes read.

This function can be used to iterate over individual packets in a PT stream for
dumping or for external decoding. The decoder needs to be advanced by the
returned number of bytes.

Libipt provides a function to do that:

         int pt_advance(struct pt_decoder *, int);


Raw packet information
----------------------

The lowest level of PT stream processing is interpreting raw bytes and bits,
separating the stream into packets and understanding the contents of each
packet. Libipt provides a function that operates on that level:

         int pt_decode(struct pt_packet *packet, struct pt_decoder *decoder);

As parameters it receives

  - packet              a struct to be filled according to what was found in
                        the low-level decode

  - decoder             a PT decoder struct

It returns the size of the decoded packet, or a negative number on error.


Libipt provides a structure to describe packet contents:

         struct pt_packet;

This structure has the following fields:

  - type                The packet type, such as TIP, FUP, etc.

                        Based on this information the user must inspect the
                        according sub-struct in the payload union (see below).

  - size                The packet size in bytes, including header and paylaod.

  - payload             Further information about the packet, depending on its
                        type (see above).


The below table indicates which sub-fields of payload should be used for the
packet type (as specified in the type field), and which structures are used
for this.

  Type          Payload sub-fields    Structure name
  ------------------------------------------------------------
  ppt_psb       n/a                   n/a
  ppt_psbend
  ppt_pad
  ppt_ovf

  ppt_fup       ip                    struct pt_packet_ip
  ppt_tip
  ppt_tip_pge
  ppt_tip_pgd

  ppt_tnt_8     tnt                   struct pt_packet_tnt
  ppt_tnt_64

  ppt_mode      mode                  struct pt_packet_mode

  ppt_pip       pip                   struct pt_packet_pip

  ppt_tsc       tsc                   struct pt_packet_tsc

  ppt_cbr       cbr                   struct pt_packet_cbr

  ppt_unknown   unknown               struct pt_packet_unknown


struct pt_packet_ip has the following fields:

  - ipc                 Information about the IP compression used,

                        field value         description
                        ------------------------------------------------------
                        pt_ipc_suppressed   suppressed IP
                        pt_ipc_update_16    16-bit payload
                        pt_ipc_update_32    32-bit payload
                        pt_ipc_sext_48      48-bit payload to be sign-extended

  - ip                  The IP carried by the packet, zero-extended to 64 bit.

                        E.g. if ipc field is pt_ipc_update_16, then the upper
                        48 bit are filled with zeros; e.g. if ipc field is
                        pt_ipc_suppressed all 64 bits are zeros.


struct pt_packet_tnt has the following fields:

  - bit_size            The number of branch taken/not-taken indications
                        carried by the packet.

  - payload             A bitfield containing the taken/not-taken indications,
                        more siginificant bits are older branch outcome
                        indications, less significant bits are more recent
                        branch outcomes.


struct pt_packet_mode has the following fields:

  - leaf                The mode leaf carried by the packet

                        field value   packet variant
                        ------------------------------------------------------
                        pt_mol_exec   execution mode information (MODE.EXEC)
                        pt_mol_tsx    transaction state information (MODE.TSX)

                        Based on this information the user must inspect the
                        according sub-struct in the bits union (see below).

  - bits                Further information about the packet, depending on its
                        leaf (see above).

    - exec                The MODE.EXEC bits information, described by
                          struct pt_packet_mode_exec.

    - tsx                 The MODE.TSX bits information, described by
                          struct pt_packet_mode_tsx.


struct pt_packet_mode_exec has the following fields:

  - csl                 The value of CS.L & EFER.LMA carried by a MODE.EXEC.

  - csd                 The value of CS.D carried by a MODE.EXEC packet.


struct pt_packet_mode_tsx has the following fields:

  - intx                The value of the InTX-bit carried by a MODE.TSX.

  - abrt                The value of the AbortTX-bit carried by a MODE.TSX.


struct pt_packet_pip has the following field:

  - cr3                 The CR3 value carried by the PIP packet.


strcut pt_packet_tsc has the following field:

  - tsc                 The TSC[55:0] value carried by the TSC packet.


struct pt_packet_cbr has the following field:

  - ratio               The core/bus ratio carried by a CBR packet.


struct pt_packet_unknown has the following fields:

  - packet              A pointer to the raw packet bytes (in the PT stream).

  - priv                An optional pointer to a user-defined structure.


Queries
-------

At a higher level, libipt provides a PT packet decoder that can be used for
reconstructing the execution flow of the traced application. On this level,
libipt serves as an oracle to guide an external instruction decoder.

After we successfully synchronized the decoder, we can start the query
interface:

         int pt_query_start(struct pt_decoder *, uint64_t *);

This will initialize the decoder state, fill in the code address at which
we can start decoding, and return a bit-vector of status bits to indicate
pending events and other status information.

In case we synchronized onto an area where PT is temporarily disabled, the
address will be set to zero and the returned status bit-vector will indicate
that the address has been suppressed. In this case, it should also return
that an event is pending which will signal the re-enabling of PT.

Now we can start querying libipt. As long as control flow is obvious, however,
we may continue decoding on our own. This includes:

 - direct branches
 - direct calls

When we reach a point where control flow is not obvious, we need to query
libipt, which provides two functions for that purpose:

         int pt_query_uncond_branch(struct pt_decoder *, uint64_t *);
         int pt_query_cond_branch(struct pt_decoder *, int *);

The first will give the destination linear address of an indirect control flow
changing instruction. We need to use this query at:

 - indirect branches
 - indirect calls
 - returns and returns from interrupt
 - system calls (sysenter, sysexit, int 8)

The second will give guidance at instructions that may change control flow
conditionally. It returns 1 in the output parameter, if the next conditional
branch was taken and it returns 0, if it was not taken. We need to use this
query at:

 - conditional branches
 - loop instructions


Events
------

Events occur asynchronously and may thus not be inferred from the
disassembly. Libipt will read ahead and notify us about upcoming events through
the return value of query and synchronization functions. The event may then be
read via another query function:

         int pt_query_event(struct pt_decoder *, struct pt_event *);

The event will typically contain the linear address at which the event occured,
except when this is obvious from the disassembly or when the address has been
suppressed. The latter will be indicated in the event.

An event may also be marked as status update. This is used for conveying the
initial state after synchronizing onto the PT stream. During normal decoding,
status update events may be used to diagnose errors.

The following events are supported:

  - PT disabled

    This event signals that PT tracing has been temporarily disabled
    due to filtering. The event contains the destination linear address
    of the branch that ended in the filtered region, unless it is
    suppressed for security reasons.

    The source address of this branch will be obvious from the
    disassembly and is thus not provided. We need to continue
    disassembling until we reach an instruction where:

      - we cannot determine the next address
      - the next address is the one contained in the event

    For CPL filtering, addresses that lie in ring 0 will be suppressed if
    ring 0 filtering is enabled. In this case, the source address will be
    the next system call instruction.


  - PT enabled

    This event signals that PT tracing has been re -enabled. It follows
    right after the corresponding disable event. The event contains the
    destination linear address of the branch that ended in the
    non -filtered region. This address is never suppressed.


  - PT asynchronous disabled

    This event is similar to PT disabled, except that the disabling
    occured due to an asynchronous branch. In addition to the destination
    address (which may be suppressed), the event contains the source address
    at which the asynchronous event occured.


  - PT asynchronous branch

    This event signals an asynchronous control flow change. The event contains
    both the source and destination address of the branch.

    For CPL filtering, the destination address may be suppressed.


  - PT paging

    This event signals that paging information has been changed. The
    event contains the updated CR3 value.

    The code address is obvious from the disassembly.  It is the first of
    the following:

    - a MOV CR3 instruction
    - a VMRESUME instruction
    - a far branch instruction


  - PT asynchronous paging

    This event signals that paging information has been changed. The
    event contains the updated CR3 value and the address at which the
    the new CR3 value effective.


  - PT overflow

    This event signals that PT data overflowed resulting in loss or trace
    data. When this event is seen, PT already recovered from the overflow and
    will proceed normally from the address contained in the event. No further
    action is necessary.


  - PT execution mode

    This event signals a change of execution mode. The event contains the new
    execution mode as well as the code address at which the execution mode
    change takes effect.

    The execution mode determines the size of code addresses as well as the
    interpretation of instructions for disassembly.


  - PT tsx

    This event signals a change with respect to speculative execution for
    transactional synchronization. The event contains the address at which the
    change comes into effect as well as a description of the transactional
    execution change.

    For nested transactions, this event is only generated for the outermost
    transaction, since inner transactions do not affect the speculative
    execution state.

    The code address may be suppressed for security reasons.


Ret compression
---------------

When PT has been configured to compress returns, a successfully compressed
return is represented as a conditional branch instead of an indirect branch.
Even though return compression has been enabled, returns may still be
represented as indirect branches.

The user would need to maintain a stack of function calls to determine the
return address of a compressed return. When encountering a call, we push the
next linear address onto our stack. When encountering a return for which we
have seen the corresponding call, we would first query for a conditional
branch. In case the query succeeds with response 'taken', we use the return
address from our call stack. In case the query fails with error rerr_bad_query,
we query for an unconditional branch.


Timing
------

When PT has been configured to generate time stamp count information, the
decoder will keep track of the time stamp count as it decodes the PT
stream. The current time stamp count value can be read using:

         uint64_t pt_query_time(struct pt_decoder *);

It will return 0 in the following cases:

  - no decoder is given
  - no time stamp count information is available

Libipt will read ahead in order to signal upcoming events. The time stamp count
returned from the above function will reflect the time stamp count for the next
event or unconditional indirect branch. That event or branch occured at or after
the respective time stamp count, whereas previous events or branches occured
before.

The time stamp count is provided by PT at irregular intervals. Although time
has definitely passed, the time stamp count may be identical for subsequent
queries.
